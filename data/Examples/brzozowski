-- brzozowski

constructs: 	star mt eps a b c final 
defuncts:	plus delta beta betaBro deltaBro unfoldB1 unfoldB2 reg1 step
		S A B 
		-- for deltaBro, betaBro and unfoldBro, see Eterm.hs
copreds:	~
fovars: 	t u w 

axioms:

delta(t+u,x) == fun((z,z),delta(t,x),
		    (mt,z),delta(u,x),
		    (z,mt),delta(t,x),
		    z,delta(t,x)+delta(u,x))(t,u) &
(beta$t=0 ==> delta(t*u,x) == fun((mt,z),mt,
				  (z,mt),mt,
				  (eps,z),delta(u,x),
				  (z,eps),delta(t,x),
		    		  z,delta(t,x)*u)(t,u)) &
(beta$t=1 ==> delta(t*u,x) == fun((mt,z),mt,
				  (z,mt),mt,
				  (eps,z),delta(u,x),
				  (z,eps),delta(t,x),
		    		  z,delta(t,x)*u+delta(u,x))(t,u)) &
delta(star$t,x) == delta(t,x)*star(t) &
delta(a,x) == ite(a=x,eps,mt) &
delta(b,x) == ite(b=x,eps,mt) &
delta(c,x) == ite(c=x,eps,mt) &
delta(eps,x) == mt &
delta(mt,x) == mt &

(beta$t=0 ==> beta$t+u == beta$u) &
(beta$t=1 ==> beta$t+u == 1) &
(beta$t=0 ==> beta$t*u == 0) &
(beta$t=1 ==> beta$t*u == beta$u) &
beta$star$t == 1 &
beta(a) == 0 &
beta(b) == 0 &
beta(c) == 0 &
beta(eps) == 1 &
beta(mt) == 0 &

unfoldB1$t == beta . foldl(delta)$t &		-- slow

unfoldB2$t == betaBro . foldl(deltaBro)$t &		

plus$t == t*star(t) &

reg1 == star$plus(a)+plus(b*c) &

-- CF grammar

step$S == a*B+b*A+eps &
step$A == a*S+b*A*A &
step$B == b*S+a*B*B &

-- state equivalence

(t ~ u ===> beta$t = beta$u & delta(t,x) ~ delta(u,x)) &

(t ~ u ===> betaBro$t = betaBro$u & deltaBro(t,x) ~ deltaBro(u,x)) 

terms:

unfoldB1(reg1)[a,b,c,a]      	<+>	--> 1		-- 26 steps 
unfoldB1(reg1)[b,c,a,c]     	<+>	--> 0		-- 22 steps 

unfoldB2(reg1)[a,b,c,a]      	<+>	--> 1		-- 26 steps 
unfoldB2(reg1)[b,c,a,c]     	<+>	--> 0		-- 22 steps 

unfoldBro(reg1)[a,b,c,a] 	<+>     --> 1	
unfoldBro(reg1)[b,c,a,c] 	<+>	--> 0	

-- unfoldB2/Bro(S) accepts words with an equal number of a's and b's

unfoldB2(S)[a,b]   		<+>	--> 1		-- 9 steps
unfoldB2(S)[a,b,a]  		<+>	--> 0		-- 11 steps

unfoldBro(S)[a,b,a,b,a,a,b,a,b,b,a,b,a,a,b,a,b,b,b,a,b,a] <+> --> 1
unfoldBro(S)$replicate(5)(a)++replicate(5)(b)		      --> 1


