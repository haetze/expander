-- stream

defuncts:   zeros ones blink blink' evens odds map zipWith zip bzip 
	    fact facts iter1 iter2 fib fib0 fib1 addTail nats loop 
	    inv switch morse morse1 morse2 morsef
preds:      X P F FS eqstream F `ble`
copreds:    NatStream G GS `le` `~`
fovars:     n z z' s s'
hovars:     X P f

axioms:

  head(zeros) == 0
& tail(zeros) == zeros

& head(ones) == 1
& tail(ones) == ones

& head(blink) == 0
& tail(blink) == 1:blink

-- & (blink = 1:blink <==> False)  	-- used in fairblink2
					-- and notfairblink2
& blink' == mu s.(0:1:s)

& head(evens(s)) == head(s)
& tail(evens(s)) == evens(tail(tail(s))) 
& odds == evens.tail

-- & tail(evens(s)) == odds(tail(s))
-- & head(odds(s)) == head(tail(s))
-- & tail(odds(s)) == odds(tail(tail(s)))

& head(map(f)(s)) == f(head(s))
& tail(map(f)(s)) == map(f)(tail(s))

& head(zipWith(f)(s)(s')) == f(head(s),head(s'))
& tail(zipWith(f)(s)(s')) == zipWith(f)(tail(s),tail(s'))

& head(zip(s,s')) == head(s)
& tail(zip(s,s')) == zip(s',tail(s))

& head(bzip(s,s',0)) == head(s)
& head(bzip(s,s',1)) == head(s')
& tail(bzip(s,s',0)) == bzip(tail(s),s',1)
& tail(bzip(s,s',1)) == bzip(s,tail(s'),0)

& fact(0) == 1
& fact(suc(n)) == n*fact(n)

& head(facts(n)) == fact(n)
& tail(facts(n)) == facts(suc(n))

& head(iter1(f,x)) == x
& tail(iter1(f,x)) == iter1(f,f(x))

& head(iter2(f,x)) == x
& tail(iter2(f,x)) == map(f)(iter2(f,x))

& nats(n) == iter1(suc,n)
& nats'(n) == iter2(suc,n)

& loop(f)(0)(x) == x
& loop(f)(suc(n))(x) == f(loop(f)(n)(x))

& head$inv$s == switch$head$s
& tail$inv$s == inv$tail$s

& switch(0) == 1
& switch(1) == 0
& switch$switch$x == x					-- used in INVINV

& head$morse == 0
& head$tail$morse == 1
& tail$tail$morse == zip(tail$morse,inv$tail$morse)

& head$morsef$s == head$s
& head$tail$morsef$s == switch$head$s
& tail$tail$morsef$s == morsef$tail$s

& head$morse1$s == head$s
& tail$morse1$s == morse2$s
& head$morse2$s == switch$head$s
& tail$morse2$s == morse1$tail$s

& fib(0) == 1
& fib(1) == 1
& fib(suc(suc(n))) == fib(n)+fib(n+1)

& head(fib0(n)) == fib(n)
& tail(fib0(n)) == fib0(n+1)

& head(fib1(n)) == fib(n)
& head(tail(fib1(n))) == fib(n+1)
& tail(tail(fib1(n))) == addTail(zip(fib1(n),tail(fib1(n))))

& head(addTail(s)) == head(s)+head(tail(s))
& tail(addTail(s)) == addTail(tail(tail(s)))

& head$s+s' == head(s)+head(s')
& tail$s+s' == tail(s)+tail(s')

-- state equivalence

& (s `~` s' ===> head$s = head$s' & tail$s `~` tail$s')	

& (eqstream <==> NU X.rel((s,s'),head$s=head$s' & X(tail$s,tail$s')))	

& (F(P)$s <=== P$s | F(P)$tail$s)			-- finally
& (G(P)$s ===> P$s & G(P)$tail$s)			-- generally

& (FS$P <==> MU X.(P\/X.tail))				-- finally
& (GS$P <==> NU X.(P/\X.tail))				-- generally

& (NatStream(x:s) ===> Nat(x) & NatStream$s)

& (s `le` s' ===> head$s `ble` head(s')) 
& (s `le` s' ===> (head$s = head$s' ==> tail$s `le` tail$s'))

theorems:
							
  iter1(f,loop(f)(n)(x)) = map(loop(f)(n))(iter2(f,x)) 	-- used in iter1iter1
& map(loop(f)(0))(s) = s                               	-- used in iter1iter1
& map(loop(f)(suc(n)))(s) = map(loop(f)(n))(map(f)(s)) 	-- used in iterloop
& loop(f)(n)(f(x)) = f(loop(f)(n)(x))                  	-- used in maploop
						       	-- see NAT (natloop)
& tail(fib1(n)) = fib1(n+1)		               	-- used in fib01
& fib((n+1)+1) = (fib(n)+fib(n+1))		       	-- used in fibtail
& evens(zip(s,s')) = s				      	-- used in evodmorse
& s `~` s						-- used in evodmorse
& zip(s,inv(s)) = morsef(s)                            	-- used in morsef

& (x `ble` z <=== x `ble` y & y `ble` z)
& (x `ble` y & y `ble` z & x = z ===> y = z & x = y)
& (x+z `ble` y+z' <=== x `ble` y & z `ble` z')

conjects:

  blink `~` zip(zeros,ones)					-- blinkzip
& evens$zip(s,s') `~` s						-- evenszip
& odds$zip(s,s') `~` s'						-- oddszip
& zip(evens$s,odds$s) `~` s	       		 		-- zipEvensOdds
& evens$x:s `~` x:odds$s					-- evensodds
& bzip(s,s',0) `~` zip(s,s') 					-- bzip
-- bzip(s,s',1) `~` zip(s',s)				
& inv$inv$s `~` s						-- invinv
& iter1(f,n) `~` iter2(f,n) 					-- iter1iter2
& iter1(f,loop(f)(n)(x)) `~` map(loop(f)(n))(iter2(f,x))	-- iterloop
& map(loop(f)(0))(s) `~` s					-- maploop0
& map(loop(f)(suc(n)))(s) `~` map(loop(f)(n))(map(f)(s))	-- maploop
& map(f)(iter1(f,x)) `~` iter1(f,f(x))   			-- mapiter1
& map(fact)(nats(n)) `~` facts(n)				-- mapfact
& fib0(n) `~` fib1(n)						-- fib01
& fib1(n+1) `~` tail(fib1(n))					-- fibtail
& tail(fib1(n+1)) `~` addTail(zip(fib1(n),tail(fib1(n)))) 	-- tailfib
& evens$morse `~` morse & odds$tail$morse `~` tail$morse    	-- evodmorse
& morsef$inv$s `~` inv$morsef$s					-- morseinv
& morse1$inv$s `~` inv$morse1$s					-- morseinv2
& morsef$morse `~` morse 					-- morsef
& zip(s,inv$s) `~` morsef$s					-- zipmorse
& morse `~` 0:zip(inv$morse,tail$morse)

& eqstream(blink,0:1:blink)
& (s = x & s' = zip(evens$x,odds$x) | 
   s = tail$x & s' = zip(odds$x,evens$x) ==> eqstream(s,s'))

& G(F$(=0).head)(blink)			--> True 		-- fairblink
& Not(G(F$(=0).head)(blink))           	--> False		-- notfairblink
& G(F$(=2).head)(blink)			--> False 		-- fairblink2
& Not(G(F$(=2).head)(blink))           	--> True		-- notfairblink2
-- & G(F$(=!x).head)(blink)		--> !x=0 | !x=1	 	-- fairblinkx
& G(F$(=0).head)(mu s.(0:1:s))		--> True		-- fairblinkmu

& GS(FS$(=0).head)$blink    		-- cyclic proof 	-- fairblinkC
& (s = blink | s = 1:blink ==> GS(FS$(=0).head)$s) 	
					--> True        	-- fairblinkS

& NatStream(mu s.(1:2:3:s))	--> True 			-- natstream
-- & NatStream(1:2:3:!s)	--> !s = 1:2:3:!s |		-- natstreamSol
				--  !s = 2:3:!s | !s = 3:!s

& (x `le` y & y `le` z ==> x `le` z)  				-- kozen1
& (x `le` y & z `le` z' ==> x+z `le` y+z') 			-- kozen2



